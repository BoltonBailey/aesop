/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Index.Basic
import Aesop.Rule.BranchState
import Aesop.Util

open Lean
open Lean.Elab.Tactic
open Lean.Meta

namespace Aesop


/-! # Rule Tactic Types -/

/--
Input for a rule tactic. Contains:

- `goal`: the goal on which the rule is run.
- `mvars`: the set of mvars which occur in `goal`.
- `indexMatchLocations`: if the rule is indexed, the locations (e.g. hyps or the
  target) matched by the rule's index entries. Otherwise an empty set.
- `branchState`: the current branch state for this rule. If the rule does not
  use branch state, this is always `RuleBranchState.initial`.
-/
structure RuleTacInput where
  goal : MVarId
  mvars : UnorderedArraySet MVarId
  indexMatchLocations : UnorderedArraySet IndexMatchLocation
  branchState : RuleBranchState
  deriving Inhabited

/--
A single rule application, representing the application of a tactic to the input
goal. Must accurately report the following information:

- `goals`: the goals generated by the tactic.
- `postState`: the `MetaM` state after the tactic was run.
-/
structure RuleApplication where
  goals : Array MVarId
  postState : Meta.SavedState
  deriving Inhabited

namespace RuleApplication

def check (r : RuleApplication) : MetaM (Option MessageData) :=
  r.postState.runMetaM' do
    for goal in r.goals do
      if ← goal.isAssigned <||> goal.isDelayedAssigned then
        return some m!"subgoal metavariable {goal.name} is already assigned."
    return none


end RuleApplication

/--
The result of a rule tactic contains:

- `applications`: a list of rule applications.
- `postBranchState?`: an updated branch state. `none` signals that there were
  no changes to the branch state, in which case the input branch state is
  copied to all subgoals.
-/
structure RuleTacOutput where
  applications : Array RuleApplication
  postBranchState? : Option RuleBranchState
  deriving Inhabited


/--
A `RuleTac` is the tactic that is run when a rule is applied to a goal.
-/
abbrev RuleTac := RuleTacInput → MetaM RuleTacOutput

abbrev SimpleRuleTac := RuleTacInput → MetaM (List MVarId)

def SimpleRuleTac.toRuleTac (t : SimpleRuleTac) : RuleTac := λ input => do
  let goals ← t input
  let postState ← saveState
  let app := { postState, goals := goals.toArray }
  return { applications := #[app], postBranchState? := none }


/-! # Branch State -/

namespace RuleTac

@[inline]
def withBranchState (check : RuleBranchState → MetaM Unit)
    (modify : RuleBranchState → RuleBranchState) (r : RuleTac) :
    RuleTac := λ input => do
  let initialBranchState := input.branchState
  check initialBranchState
  let output ← r input
  let newBranchState := modify $ output.postBranchState?.getD initialBranchState
  return { output with postBranchState? := some newBranchState }

def withApplicationLimit (n : Nat) : RuleTac → RuleTac :=
  withBranchState
    (λ bs => do
      if bs.numApplications >= n then
        throwError "Rule is limited to {n} application(s) per branch.")
    (λ bs => { bs with numApplications := bs.numApplications + 1 })

end RuleTac


/-! # Rule Tactic Descriptions -/

def CasesPattern := AbstractMVarsResult
  deriving Inhabited

inductive CasesTarget
  | decl (decl : Name)
  | patterns (patterns : Array CasesPattern)
  deriving Inhabited

inductive RuleTacDescr
  | applyConst (decl     : Name)
  | applyFVar  (userName : Name)
  | constructors (constructorNames : Array Name)
  | forwardConst (decl     : Name) (immediate : UnorderedArraySet Nat) (clear : Bool)
  | forwardFVar  (userName : Name) (immediate : UnorderedArraySet Nat) (clear : Bool)
  | cases (target : CasesTarget) (isRecursiveType : Bool)
  | tacticM (decl : Name)
  | ruleTac (decl : Name)
  | simpleRuleTac (decl : Name)
  deriving Inhabited

namespace RuleTacDescr

def isGlobal : RuleTacDescr → Bool
  | applyConst .. => true
  | applyFVar .. => false
  | constructors .. => true
  | forwardConst .. => true
  | forwardFVar .. => false
  | cases .. => true
  | tacticM .. => true
  | ruleTac .. => true
  | simpleRuleTac .. => true

end RuleTacDescr

end Aesop
